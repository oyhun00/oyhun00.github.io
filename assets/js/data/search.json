[ { "title": "JavaScript Memory", "url": "/posts/javascript-garbage-collection/", "categories": "JavaScript, Core", "tags": "JavaScript", "date": "2023-08-15 12:58:00 +0900", "snippet": "JavaScript Memory자바스크립트에서 메모리 관리는 자바스크립트 엔진에서 자동적으로 관리해준다. 하지만 자바스크립트를 사용하는 개발자라면 어느 정도 이해는 해놔야 될 것 같아 정리하였다.🔹자바스크립트 메모리 생명 주기자바스크립트 엔진은 변수나 함수 등을 생성할 때, 메모리를 할당하고 필요하지 않으면 해제한다. 메모리 할당은 말 그대로 메모리에 공간에 할당하는 행위이며, 해제는 할당된 공간을 비워 다른 메모리를 할당한다.Allocate (할당)자바스크립트에서 생성한 객체에 필요한 메모리를 할당한다.Use (사용)코드에서 명시적으로 수행되는 작업으로. 변수를 사용하거나 읽는 작업 하며 메모리를 읽고 쓴다.Release (해제)자바스크립트 엔진에서 사용하지 않는 변수나 함수를 해제한다.🔹Heap and Stack자바스크립트 엔진에는 데이터를 저장하는 힙과 스택이라는 공간이 존재한다.Stack - 정적 메모리 할당스택은 자바스크립트에서 정적 데이터를 저장하는데 사용하는 자료 구조이다. 자바스크립트에서 정적 데이터는 원시 값 (number, string, boolean, undefined, null)과 객체나 함수를 가리키는 참조이다.정적 데이터는 크기가 변하지 않고 정적임으로 엔진에서 고정된 크기의 메모리를 사전에 할당한다. 그리고 이를 실행 직전에 메모리를 할당한다 해서 정적 메모리 할당이라 한다.Heap - 동적 메모리 할당힙은 스택과 달리 고정된 크기의 메모리를 할당하지 않는다. 필요에 따라 동적으로 공간을 할당하게 되고 이를 동적 메모리 할당이라 한다. 대표적으로 오브젝트나 객체를 힙에 저장하게 된다.🔹자바스크립트의 참조자바스크립트에서 모든 변수는 스택을 가장 먼저 가르킨다. 이때 원시 값이 아닌 경우에는 스택에는 힙에 존재하는 객체에 대한 참조가 저장하게 된다.힙은 스택과 달리 정렬에 대한 규칙이 존재하지 않아 스택에 대한 참조를 유지해야 한다.🔹자바스크립트 가비지 콜렉션자바스크립트 엔진에서 메모리 할당 해제는 가비지 콜렉터가 담당한다. 엔진이 특정 변수나 함수가 더 이상 사용되지 않음을 판단하면 이를 해제해준다.하지만 확실하게 메모리가 여전히 사용중인지 아닌지를 판별할 수 없다. 이는 더 이상 필요하지 않은 공간을 정확한 타이밍에 가비지를 콜렉션할 수 있는 완벽한 알고리즘이 존재할 수 없다고 한다.완벽하게 정확한 시점에서 메모리를 해제할 수 있진 않지만, 어느 정도 목표를 달성할 수 있는 가장 많이 사용되는 두 가지 가비지 콜렉션 알고리즘이 있다.Reference-counting Garbage Collection이 알고리즘은 가리키는 참조가 없는 객체를 수집한다.hobbies 변수는 참조가 존재하는 객체이기 때문에 힙에서만 유지되고 있다.하지만 이 알고리즘은 순환 참조를 고려하지 않고 있다.let son = { name: 'John',};let dad = { name: 'Johnson',};son.dad = dad;dad.son = son;son = null;dad = null;son 과 dad 객체가 서로를 참조하기 때문에, 알고리즘이 이 변수들이 사용되고 있는지를 판별할 수 없게 된다.Mark and Sweep Algorithm이 알고리즘은 순환 참조에 대한 문제점을 해결할 수 있다. 주어진 객체에 대한 참조를 계산하는 대신, 루트 객체에서 도달할 수 있는지를 감지한다. 여기서 루트는 브라우저에서 window 객체, Nodejs에서 global 객체를 가리킨다.루트가 참조하는 객체들, 그리고 그 객체에서 참조하는 또 다른 객체들을 탐색하며 마크를 한다. 이러한 마크가 끝나면 가비지 컬렉터는 힙 내부 전체를 돌며 마크되지 않은 영역을 해제한다. 이러한 과정을 Sweep이라 한다. 이렇게 되면 순환 참조가 더 이상 문제되지 않는다.🔹자바스크립트 GC의 단점메모리 사용량앞서 기술했듯이, 가비지 컬렉터가 정확한 타이밍에 가비지를 콜렉션 할 수 없다는 점을 보았을 때, 자바스크립트는 실제로 필요한 것보다 더 많은 메모리를 사용할 수 있다고 한다.만약 메모리 효율을 최대로 끌어올려야 할 때, JS가 아닌 다른 Low-level 언어를 사용하는 것이 좋다.🔹자바스크립트 메모리 누수전역 변수대표적으로 브라우저에서 const 나 let 키워드 대신 var 를 사용하거나 생략하는 경우, 엔진이 변수를 window 객체에 할당한다. 이는 function 으로 정의한 함수도 마찬가지다.user = getUser();var secondUser = getUser();function getUser() { return 'user';}전역 변수를 사용하게 된다면, 필요하지 않을 경우 메모리 공간을 확보해주는 것이 좋다. null 을 할당하여 메모리를 해제한다.window.users = null;타이머 및 콜백자바스크립트에서 setInterval 과 같은 타이머 함수를 선언하고 clear 하지 않으면 메모리 사용량이 증가한다. 특히 SPA에서 이벤트 리스너와 콜백을 동적으로 추가할 때 주의해야 한다.const object = {};const intervalId = setInterval(function() { doSomething(object);}, 2000);위 코드는 2초마다 함수를 실행시키고, interval이 취소되지 않으면, 참조된 객체들은 가비지 컬렉터에 수집되지 않는다. 만약 더 사용하지 않는다면 다음과 같이 해제한다.clearInterval(intervalId);SPA 같은 경우에서 특히나 주의해야하는 이유는 다른 페이지로 이동해도 여전히 백그라운드에서 실행 될 수 있기 때문이다.DOM 참조자바스크립트에 DOM Element를 저장할 때 발생하게 된다.const elements = [];const element = document.getElementById('button');elements.push(element);function removeAllElements() { elements.forEach((item) =&gt; { document.body.removeChild(document.getElementById(item.id)) });}Element를 제거할 때, 배열에서도 제거해줘야 한다. 그렇지 않으면 가비지 컬렉터가 수집할 수 없다.const elements = [];const element = document.getElementById('button');elements.push(element);function removeAllElements() { elements.forEach((item, index) =&gt; { document.body.removeChild(document.getElementById(item.id)); elements.splice(index, 1); });}모든 DOM Element는 부모 노드에 대한 참조도 유지하기 때문에, 가비지 콜렉터가 Element의 부모와 자식을 수집하는 것을 방지할 수 있다.📚 Reference https://felixgerschau.com/javascript-memory-management/#trade-offs https://velog.io/@sejinkim/자바스크립트의-메모리-관리-설명해당 포스트는 위 레퍼런스를 통해 작성하였습니다. 그런데 Mark and Sweep Algorithm에서 도달할 수 없는 객체를 마크 처리하고, 마크 처리된 객체를 Sweep한다고 나와 있지만, JVM에선 참조할 수 없는 객체를 마크 처리한다는 점에서 차이점이 나타나 다음 포스트들을 참조하여 도달할 수 있는 객체를 마크 처리 하는것으로 수정하여 작성하였습니다. 만약 이 내용이 잘못된 내용이라면 피드백 부탁드립니다. https://v8.dev/blog/concurrent-marking#background https://ko.javascript.info/garbage-collection#ref-35" }, { "title": "Webpack -> Vite Migration", "url": "/posts/wepback-vite-mitgration/", "categories": "React, FE Tech", "tags": "React, Vite, Webpack, Bundler", "date": "2023-02-07 12:58:00 +0900", "snippet": "AD Platform Webpack → Vite Migration회사에서 기존 AD Platform에서 새로운 Feature를 개발하는 도중, 프로젝트 규모 자체가 커서 그런지 HMR과 서버를 재시작하거나 빌드할 때 시간이 상당히 오래 걸렸다. 그 전에 다른 프로젝트에서 Vite를 도입했던 기억이 떠올라 이번엔 Webpack에서 Vite로 마이그레이션을 해보기로 했다.⚙️ 기존 환경 Dependencies Version react 17.0.2 webpack 4.42.0 🔄 Migration🔹 Vite InstallVite에서 React 플러그인 기능을 사용하기 위해 다음과 같이 플러그인을 설치했다.yarn add -D vite @vitejs/plugin-react설치 후, 프로젝트 루트에 vite.config.ts 파일과 index.html 파일을 생성하여 다음과 같이 설정한다.import { defineConfig } from \"vite\";import react from \"@vitejs/plugin-react\";import envCompatible from \"vite-plugin-env-compatible\";export default defineConfig({ plugins: [react(), envCompatible({ prefix: \"REACT_APP\" })], publicDir: false,});&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; ... &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"module\" src=\"./src/index.tsx\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;index.html 파일을 public 디렉터리가 아닌 루트에 생성한 이유는 Vite의 의도적인 구조이다. 추가적인 번들링 과정 없이 index.html 파일이 앱의 진입점이 되기 위한 의도이다.yarn add -D vite-plugin-env-compatibleVite에선 환경 변수에 접근할 때, process.env 대신 import.meta.env 를 통해 접근한다. 하지만 기존 프로젝트에서의 환경 변수를 Vite의 환경 변수 접근 방식으로 수정하려면 리소스를 많이 소요하게 된다. 따라서 기존 process.env 을 통해 접근할 수 있도록 도와주는 플러그인을 설치한다.🔹 ProxyVite에서 프록시는 vite.config.ts 에서 설정할 수 있다. 참고vite.config.ts 파일에서 환경 변수를 통해 프록시를 다음과 같이 설정하였다....export default ({ mode }) =&gt; {\tconst envDir = `../environments` process.env = { ...process.env, ...loadEnv(mode, envDir, '') }\t...\treturn defineConfig({\t\t...\t\tserver: {\t proxy: {\t '/auth': {\t target: `${AuthURL}`,\t changeOrigin: true,\t rewrite: path =&gt; path.replace(/^\\/api/, ''),\t },\t\t\t\t...\t\t\t}\t\t},\t\tpreview: {\t proxy: {\t '/auth': {\t target: `${AuthURL}`,\t changeOrigin: true,\t rewrite: path =&gt; path.replace(/^\\/api/, ''),\t },\t\t\t\t...\t\t\t}\t\t}\t})}🚀 Trouble Shooting🔹 The following dependencies are imported but could not be resolved기본적인 Vite 설정 완료 후, 실행 했더니 다음과 같이 에러가 나타났다.이는 Vite의 모듈 번들러인 Rollup의 파일 탐색 방식 때문인데, rollup 설정의 build.rollupOptions.external 이 외부 파일보다 / 을 먼저 찾기 때문에 발생한 오류였다.&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"module\" src=\"./src/index.tsx\"&gt;&lt;/script&gt;&lt;/body&gt;기존의 index.html 파일에서는 위와 같이 설정되어 있었다. 아래처럼 . 를 제거하니 정상적으로 실행이 완료되었다.&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"module\" src=\"/src/index.tsx\"&gt;&lt;/script&gt;&lt;/body&gt;🔹 Internal server error: Failed to resolve import “…” from “src/index.tsx”. Does the file exist?서버가 정상적으로 실행되는 듯 했으나 이번에도 경로를 찾지 못해 파일을 불러오지 못하는 에러가 발생했다. 프로젝트 내부에서 모든 파일 코드를 수정하기엔 큰 리소스 소모가 필요해보였다. 이는 vite-tsconfig-paths 플러그인을 설치하여 해결하였다. 해당 플러그인은 TypeScript의 경로 매핑을 그대로 사용할 수 있게끔 도와주는 플러그인이다.yarn add -D vite-tsconfig-paths그리고 vite.config.js 파일을 다음과 같이 수정하였다.import { defineConfig } from \"vite\";import react from \"@vitejs/plugin-react\";import tsconfigPaths from \"vite-tsconfig-paths\";import envCompatible from \"vite-plugin-env-compatible\";export default defineConfig({ plugins: [react(), tsconfigPaths(), envCompatible({ prefix: \"REACT_APP\" })], publicDir: false, base: \"/\",});🔹 Require is not definedVite는 기본적으로 ES Module 방식을 사용하기 때문에, require 문(CJS)을 사용하면 require is not defined 에러를 출력한다.이는 vite 프로젝트에서 require를 사용할 수 있게끔 도와주는 플러그인을 설치하여 해결하였다. 링크yarn add vite-plugin-require...import vitePluginRequire from 'vite-plugin-require'export default defineConfig({ plugins: [\t\t...\t\tvitePluginRequire({ fileRegex: /.ts$|.tsx$|.jpg$|.png$/, }),\t\t...\t], ...})🔹 Please import the top-level fullcalendar lib before attempting to import a plugin.해당 이슈는 fullcalendar 디펜던시 버전을 업데이트하며 해결되었다.이 외에도 여러가지 자질구레한 플러그인 버전 충돌, 경로 오타(이거 때문에 하루 종일 삽질) 등등 이슈가 많이 나타났었다.🌟 결과🔹 Hot Module Reload Webpack Vite 🔹 Build Time Webpack: 45s Vite: 24s🔹 Cold Start Webpack: 약 16s Vite: 약 4s아직 전체적으로 테스트를 해보진 못했지만, 속도가 비약적으로 향상되어 앞으로 개발 생산성도 같이 향상 될 것으로 기대하고 있다." }, { "title": "IAB OpenDirect", "url": "/posts/iab-open-direct/", "categories": "AD Tech, IAB OpenDirect", "tags": "OpenDirect, ad, AD Tech, DSP, SSP, DMP", "date": "2022-11-06 12:58:00 +0900", "snippet": "해당 포스트는 IAB OpenDirect 공식 문서를 나름 번역하며 공부하고 정리한 글이며 빠진 내용 혹은 오역, 잘못된 내용이 있을 수 있음🖥️ Open DirectOpen Direct를 통해 퍼블리셔가 구매자에게 Open Direct의 표준에 맞춰 구축한 프로그래매틱한 인터페이스를 통해 광고 인벤토리를 제공할 수 있다. 인벤토리란? - 퍼블리셔가 판매할 수 있는 광고 지면, 매체를 뜻함각 기업 마다의 인터페이스를 통해 구매 및 판매를 전반적으로 걸쳐 재고를 관리한다. 각 구매자와 판매자의 시스템은 인터페이스가 서로 다르기 때문에, 시스템을 통합하기 위해선 많은 리소스를 소요하게 된다.이를 위해 Open Direct를 통해 광고 인벤토리를 공급자와 수요자가 사용할 수 있게 끔 표준 인터페이스를 제공해준다.판매자의 경우 프로그래매틱한 마켓 플레이스에서 구매자에게 다양한 프리미엄 보장 인벤토리를 제공할 수 있다. 또한 이 광고 인벤토리를 추적할 수 있어 가시적인 리포트를 제공하고, 노출 수와 송출 수를 계산할 수 있도록 기반을 제공해준다. 자동 보장 인벤토리를 제공하기 위한 인터페이스를 설계할 때 Open Direct API를 사용할 수 있다.공급자(판매자, 퍼블리셔) - 광고 지면을 제공하는 혹은 소유하고 있는 매체, 즉 광고 내용을 소비자에게 전달하는 매개체수요자(구매자) - 광고주, 광고 지면을 필요로 하는 사람, 즉 광고주와 퍼블리셔는 광고 시장을 형성하는 핵심 주체, 광고를 제공하는 사람🔧 Open Direct의 주요 기능 광고 인벤토리 검색 가격 설정 타겟팅 및 빈도 수 제약 조건 적용 캠페인(Order) 혹은 광고 항목(Line) 추가 광고 소재(Creative) 업로드, 광고 항목(Line)에 광고 소재(Creative) 할당🛣️ 작동 방식 수요자 공급자 수요자는 공급자로부터 OpenDirect에서 사용할 수 있는 ID를 얻는다. 수요자가 광고 인벤토리를 사용하기 위해서 ID를 제공해준다. 공급자로부터 얻은 계정을 통해 광고 인벤토리를 탐색한다. 수요자가 Open Direct 기반의 시스템에서 액세스 할 수 있는 계정을 만든다. 탐색한 광고 인벤토리에 캠페인(Order)에 광고 항목(Line)을 추가한다. 수요자가 요청하는 API를 수신받고, 이에 응답한다. 캠페인(Order) 설정이 완료되면, 공급자의 승인을 위해 광고 소재(Creative)를 제출하고, 승인이 되면 캠페인(Order)이 송출 될 수 있도록 예약할 수 있다. 수요자가 제출한 광고 소재(Creative)를 승인 혹은 반려 처리한다. 🗂️ Spec출처: IAB Open Direct Document📋 ObjectAccountAccount는 구매자(수요자) - 광고주 관계를 정의한다. 구매자는 일반적으로 광고주를 대신하여 주문하는 대행사다.각 Account는 구매자를 광고주와 연결하고 판매자(공급자)의 캠페인(Order)을 관리하는 데 사용된다. 광고주는 여러 구매자들과 작업할 수 있으므로 작업하는 구매자에 대해 각각 별도의 계정을 갖게된다.대행사(구매자)가 광고주를 대신하여 Account를 만들고 구매를 하기 위해선 광고주가 대행사(구매자)에게 권한을 부여해야 한다. 만약 권한을 부여받지 못한 대행사(구매자)가 Account 생성 시 실패해야한다. 권한을 부여하는 작업은 판매자(공급자)가 정의한다. 속성 내용 타입 id* - 시스템에서 생성되는 식별 가능한 고유 opaque 타입 ID string(36) advertiserid* - 광고주를 식별하는 ID - 공급자가 수요자에게 생성하는 ID - 자신을 나타내는 광고주는 AdvertiserId 혹은 BuyerId가 있어야함 string(36) buyerid* - 구매자 역할을 하는 조직을 식별하는 ID - 판매자(공급자)가 BuyerId를 생성함 - 광고주가 직접 구매를 수행하는 경우, AdvertiserId와 BuyerId가 동일해야함 string(36) name* - 계정의 이름 string(255) ext - Optional vendor-specific extensions. ext object AdUnit각 광고 단위에는 하나의 AdCOM 광고 사양이 포함됨 속성 내용 타입 id* - 해당 광고 단위를 고유하게 식별하는 ID string(36) name - Ad Unit의 고유한 이름 string(255) spec* - The technical specifications of this Ad Unit AdCOM Placement object Address주소 객체는 Organization에 대한 값을 제공하는데 사용 속성 내용 타입 city* - organization의 주소 상에 입력된 도시 이름 string(255) country* - organization의 지역 string(255) addressline1* - organization의 기본 주소 string(255) addressline2* - organization의 상세 주소 string(255) postalcode - 주소의 우편번호 혹은 ZIP Code string(15) state - organization의 행정 주소 string(36) AssignmentAssingment는 광고 소재(Creative)를 캠페인(Order)의 광고 항목(Line)과 연관시킨다. 광고 소재(Creative)는 하나 이상의 광고 항목(Line)에 할당될 수 있고, 광고 항목(Line)은 하나 이상의 광고 소재(Creative)에 할당될 수 있다. 속성 내용 타입 id - 시스템에서 생성되는 식별 가능한 고유 opaque 타입 ID string(36) creativeid* - 광고 항목에 표시되는 광고 소재의 ID string(36) placementid* - 광고 소재를 표시할 placement의 ID string(36) status - 광고 소재 표시 여부 결정 값 - 비활성화 상태에서 활성화 상태로 못바꿀 수도 있음 enum (Active, Inactive) weight - 동일한 광고 항목에 할당되어 있는 여러개의 광고 소재에서 해당 광고 소재 표시량의 가중치를 결정 - 가중치를 지정하지 않으면 일정한 가중치 제공 - 가중치가 하나라도 적용되어 있다면, 동일한 광고 항목에 속한 모든 Assignment는 가중치를 지정해야함 - 모든 Assignment의 가중치 합이 최대 100이 되지 않으면 균등 순환이 적용됨 - ex: 동일한 날짜의 광고 항목에 할당된 광고 소재 A의 가중치가 25, B의 가중치가 75라면 B는 A보다 3배 더 자주 표시된다. integer (1-100) ext Optional vendor-specific extensions. ext object ChangeRequest캠페인(Order)이 진행되고 있는 동안 변경이 필요할 때, ChangeRequest를 통해 변경을 요청하고 승인을 기다리는 동안 캠페인(Order)를 수정할 수 있다. 속성 내용 타입 id - 시스템에서 생성되는 식별 가능한 고유 opaque 타입 ID string(36) accountid* - ChangeRequest 권한을 소유한 광고주와 수요자를 식별하기 위한 Account ID - 캠페인(Order)의 Account ID와 동일해야함 string(36) comments - 변경이 필요한 설명 string(1000) contacts - 연락처 목록 - 구매자 및 광고주의 연락처 목록에 추가됨 - 목록에는 고유한 연락처 Type이 포함되어야 함 CONTACT array orderid* - 변경 요청된 캠페인(Order)의 ID string(36) requesterid* - 대행사에서 변경 요청일 경우 AgencyID - 판매자(공급자)가 변경 요청한 경우 PublisherID string(36) status - 변경할 상태 지정 enum (PENDING, APPROVED, REJECTED) webhook - 판매자(공급자)가 변경을 승인, 거부, 수정할 때 호출되는 URI - URI는 변경 요청 ID가 포함된 PUT과 함께 호출 string(36) ext Optional vendor-specific extensions. ext object Creative광고 소재(Creative)는 캠페인(Order)의 광고 항목(Line)에 표시할 광고에 대한 정보를 제공한다. Assignment 리소스를 통해 캠페인(Order)의 광고 항목(Line) 리소스가 광고 소재(Creative)에 할당된다 속성 내용 타입 accountid* - 광고 소재(Creative)를 소유한 Account ID string(36) name - 광고 소재(Creative) 이름 string(255) ad - 광고 소재(Creative)의 메타 데이터, 콘텐츠 AdCOM Ad object creativeapprovals - 각 판매자(공급자)에 대한 승인 상태를 나타내는 항목 Key/Value array ext Optional vendor-specific extensions. ext object Line광고 항목(Line)은 캠페인(Order)에 포함되며, 제품의 상태, 시작 혹은 종료 날짜, 캠페인(Order) 항목에 대한 세부 정보를 제공한다.광고 소재(Creative)는 Assignment 리소스를 통해 캠페인의 광고 항목에 할당된다.광고 항목은 상태가 초안 상태일 때만 변경할 수 있다. 상태가 예약 혹은 거부 상태일 경우 광고 항목을 수정하기 위해 reset을 호출하여 광고 항목을 초안 상태로 다시 변경할 수 있다 속성 내용 타입 id - 시스템에서 생성되는 식별 가능한 고유 opaque 타입 ID string(36) name* - 광고 항목(Line)의 고유한 이름 string(200) orderid* - 광고 항목이 속한 캠페인(Order)의 ID string(36) productid* - 광고 소재가 실행되는 제품의 ID string(36) bookingstatus* - 광고 항목이 예약되었고, 광고를 전달할 수 있는지 결정하는 값 - 광고 항목이 재설정되면 statechangereason 내용을 지워야한다. enum (Draft, PendingReservation, Reserved, PendingBooking, Booked, InFlight, Finished, Stopped, Canceled, Pause, Expired, Declined, ChangePending) statechangereason - 상태를 변경한 이유 string startdate* - 광고 항목이 시작되는 날짜 - 시간은 오전 12시가 기본 값 - 시작일은 현재보다 같거나 이후여야 하고, 캠페인(Campaign)의 시작일 보다 같거나 이후여야 한다. - 캠페인의 시작일보다 이전일 경우, 날짜가 일치하도록 캠페인의 시작일을 변경해야함 string (date-time) enddate* - 광고 항목이 종료될 날짜 - 시간은 오후 11시 59분 59초가 기본 값 - 종료일은 시작일 이후여야 하고, 캠페인(Campaign)의 종료일 보다 이전이거나 같아야한다. - 캠페인의 종료일보다 이후일 경우, 날짜가 일치하도록 캠페인의 종료일을 변경해야함 string (date-time) ratetype* - cost가 표현되는 측정 단위 정의 enum (CPM, CPMV, CPC, CPD, FlatRate) rate* - 노출 단위 당 가격 1,000회 노출 마다 $10(CPM) - 요금은 광고 항목이 추가, 수정, 예약될 때마다 결정 됨 number quantity* - 지정된 기간에서 요청된 수량 - 수량 값은 ratetype에 따라 달라짐 - 광고 항목은 예약할 때 수량을 포함해야함 - 요청된 수량을 사용할 수 없을 경우 bookingStatus는 Declined로 설정되어야함 integer cost* The projected cost of the line is based on the specified quantity, rate and targeting. The actual cost (the amount billed) is based on the actual number of mpressions. The cost is specified in the currency for the order. If the order uses a different currency than what the product uses, the cost for the line must be converted to the order’s currency. The cost is determined at the time the line is saved with the following statuses: Drafted, Reserved, or Booked. number comment - 참고하기 위한 항목 string (255) frequencycount The maximum number of times that a unique user must see ads from this line during the specified interval (see FrequencyInterval). integer frequencyinterval Defines the frequency cap intervals that the API supports. The frequency interval specifies the units in which the frequency count is expressed. For example, if a line’s frequency count is 2 and interval is Day, display the ad to the same user a Max 2 times in the same calendar day. enum (Day, Month, Week, Hour, LineDuration) reservedexpirydate The date and time that the reserved inventory will expire. If the line is reserved, the expiry date must be set. string (date-time) targeting The creative assigned to the LINE resource is display when the line includes user segments and the delivery engine can determine whether the user matches the specified segments. AdCOM Segment object array pmp     ext Optional vendor-specific extensions. ext object MessageOrderOrganizationPlacementProductStats🔃 Workflow대행사(구매자) 등록대행사(구매자)는 퍼블리셔가 직접 등록한다. 해당 프로세스는 판매자(공급자)가 정의하며 판매자에 따라 다르다. 대행사에 조직이 추가되면 대행사에서 광고 고객을 위한 조직을 만들 수 있다. 조직에 존재하는 사용자들은 각자의 고유한 자격 증명을 가지고 있어야 한다.광고주(Organization) 조직 등록광고주는 퍼블리셔에게 직접 가입하거나, 대행사가 광고주를 대리할 수 있다. 광고주는 하나 이상의 조직을 만들 수 있다. 특정 조직을 만들면 해당 조직에 브랜드, 혹은 자회사에 대한 account를 만들 수 있다. 이러한 조직의 구성도는 광고주의 판단으로 자율적으로 구성할 수 있다. 그리고 각 조직의 사용자들은 고유한 자격 증명을 가지고 있어야 한다.OAuth 2.0 Access Token공급자는 OAuth 2.0을 통해 사용자를 인증해야 한다. 모든 API 호출에서 헤더에 OAuth Access Token이 필요하다.인증 서비스에서 Access Token과 Refresh Token 및 만료 시간을 반환한다. Refresh Token을 이용하여 Access Token을 받으면 된다.계정 등록광고주의 재량에 따라 조직을 구성하고 각 조직에 해당하는 account를 만들 수 있다 했다. 광고주를 대행하는 대행사는 광고주의 accept가 있어야 한다. 이러한 광고주의 account를 관리할 수 있는 권한을 대행사에게 부여하는 과정은 퍼블리셔가 직접 정의한다.account는 캠페인(Order) 혹은 광고 소재(Creative)와의 관계가 포함된다.인벤토리와 Availability, 가격 가져오기The following provides several options for getting product inventory details. Typically, you’d use the first two options to present a product catalog and the last option to add and book a line.사용자에게 보여줄 제품 카탈로그를 가져오려면 /products 에 GET 요청을 보낸다. 응답으로 Product 객체를 받고, 이 Product 객체에는 제품의 예상 일일 노출 수, base rate가 포함된다.Providers should not use the avails search method (option 3) to determine estimated avails.캠페인(Order) 생성캠페인(Order)는 광고 항목(Line)의 상위 컨테이너이다. 캠페인(Order)에 광고 항목(Line)을 추가하려면 POST /accounts/{id}/orders 로 API Call을 보낸다.캠페인(Order)에 광고 항목(Line) 추가광고 항목(Line)은 예약할 광고 제품, 수량, 타겟팅 정보와 광고 항목이 실행되는 기간을 지정한다. 캠페인에 광고 항목을 추가하려면 POST /accounts/{id}/orders/{id}/lines 로 요청을 보낸다.광고 항목의 상태는 초안 상태에서만 업데이트할 수 있다.광고 소재(Creative) 업로드 및 Assignment(할당)광고 소재를 업로드 한다. POST /accounts/{id}/creatives 요청을 보내면 된다.대부분의 광고 소재는 광고 항목에 할당되기 전에 승인을 거쳐야 할당이 가능하다. 이 광고 소재의 상태를 확인하고 광고 항목에 할당한다. 광고 항목을 예약하기 전에 할당된 광고 소재가 있어야 한다. 이 광고 소재는 광고주가 실행하려는 실제 광고 소재이거나, 대체되는 광고 소재일 수 도 있다.광고 항목 예약 및 취소광고 항목을 예약 또는 취소하려면 각각 다음 URI에 PATCH 또는 PUT 요청을 보낸다./accounts/{id}/orders/{id}/lines/{id}?reserve/accounts/{id}/orders/{id}/lines/{id}?book/accounts/{id}/orders/{id}/lines/{id}?cancel🗞️ 다이어그램퍼블리셔 Workflow Diagram출처: IAB Open Direct Document구매 대행사 및 광고주 Workflow Diagram출처: IAB Open Direct Document작성중" }, { "title": "Vite 알아보기", "url": "/posts/vite/", "categories": "React, FE Tech", "tags": "React, Build, ESM, Esbuild", "date": "2022-10-06 12:58:00 +0900", "snippet": "Vite✏️ Vite란? 빠르다, 날쌔다, 신속하다. Vite는 프랑스어로 빠르다라는 뜻이 있다. 웹 어플리케이션의 빌드를 도와주는 도구인데, 말 그대로 빠른 속도로 빌드를 도와준다. 공식 문서에서는 두 가지의 컨셉을 잡고 있다고 한다. 개발 시 네이티브 ES Module을 넘어 더욱 다양한 기능을 제공합니다. 가령, Hot Module Replacement (HMR)과 같은 것들 말이죠. 번들링 시, Rollup 기반의 다양한 빌드 커맨드를 사용할 수 있습니다. 이는 높은 수준으로 최적화된 정적(Static) 리소스들을 배포할 수 있게끔 하며, 미리 정의된 설정(Pre-configured)을 제공합니다.보통 리액트를 초기 구성할 때, 자바스크립트로 이루어진 Webpack을 사용한다. 이 Webpack과 같은 JS 기반의 도구들은 프로젝트의 규모가 커질수록 번들크기가 커지며 빌드 속도가 점점 오래 걸리기 시작한다. 그리고 HMR(Hot Module Replacement)을 사용하더라도 적용되는데에 오랜 시간이 걸린다.Vite 공식 문서🔨 Vite로 React 프로젝트 구성해보기React + Typescript 구성NPM$ npm create vite@latest project-name --template react-tsYarn$ yarn create vite project-name --template react-ts사용해보면 알듯이, 명령어 단 한줄로 간단하고 빠르게 Typescript + React 프로젝트가 구성된다. 이 외에도 다음과 같이 여러가지 템플릿들을 지원하고 있다. JavaScript TypeScript vanilla vanilla-ts vue vue-ts react react-ts preact preact-ts lit lit-ts svelte svelte-ts 설치 후, 프로젝트 구조create-vite 를 통해 설치 된 프로젝트 구조를 살펴보면, index.html 파일이 public 폴더가 아닌 프로젝트 루트 경로에 위치하고 있다. 이것은 vite의 의도이며, 추가적인 번들링 과정 없이 index.html 파일이 앱의 진입점이 되게끔 하기 위함이라고 한다. 자세한 설명CLI기본적으로 제공하는 커맨드라인은 다음과 같다.{ \"scripts\": { \"dev\": \"vite\", // 개발 서버 실행 \"build\": \"vite build\", // 빌드 실행 \"preview\": \"vite preview\" // 빌드에 대한 프리뷰 서버 실행 }}📙 지원하는 기능TypeScriptVite에서 TypeScript 파일에 대한 컴파일링과 import도 지원해준다. 하지만 vite 자체에서 TypeScript 파일의 타입 체킹 작업을 따로 하진 않고, IDE나 빌드 프로세스에 의존한다. 만약 타입 체킹이 필요하다면 tsc --noEmit 을 빌드 스크립트에 넣어주면 가능해진다.Vite의 TypeScript 컴파일링은 Esbuild를 통해 진행하고, TypeScript 코드를 JavaScript 코드로 변환하는 속도는 기존 tsc 에 비교하면 약 20~30배 빠른 퍼포먼스를 보여 준다고 한다.컴파일러 옵션Esbuild는 타입에 대한 정보 없이 변환만을 수행하기에 상수형 enum 혹은 암묵적으로 타입만을 가져오는 특정 기능들을 지원하지 않는다.이를 지원하기 위해서 tsconfig.json 의 compilerOptions 에서 \"isolatedModules\": true 로 설정해주면 된다. 해당 설정으로 위와 같은 상황에서 작동하지 않는 기능들에 대해 경고할 수 있게 된다.CSSvite에서 css 파일을 import 할 때, HMR을 위해 &lt;style&gt; 태그로 변환되어 불러온다.import style from \"./layout.css\";console.log(style); // 정의한 CSS를 String으로 가져온다.JSONJSON 파일은 바로 import가 가능하고, 가져올 필드도 지정할 수 있다.import json from \"./object.json\"; // 객체로 가져오기import { field } from \"./object.json\"; // 필드를 지정하여 트리 쉐이킹하기동적 import변수를 통해 동적인 import 기능도 지원한다.const module = await import(`./src/${file}.js`);CSS 코드 분리비동기적으로 불러와지는 chunk에서 CSS 코드가 포함되어 있을 때, 자동으로 추출하며 파일로 분리한다. 그 이후 &lt;link&gt; 태그를 이용해 분리된 CSS 코드를 불러오며, 모두 계산이 마무리 된 후에 chunk를 렌더한다. 이러한 과정을 거치는 이유는 CSS가 렌더링 될 때 화면이 잠시 반짝거리는 현상(FOUC)을 피할 수 있기 때문이다.만약 모든 CSS가 일반적인 파일로 저장된 경우라면 build.cssCodeSplit 옵션 값을 false로 설정하여 비활성화한다." }, { "title": "옵저버 패턴을 리액트에서 사용해보기", "url": "/posts/design-pattern-observer-in-react/", "categories": "Design Pattern, React", "tags": "Design Pattern, Observer Pattern, React", "date": "2022-08-29 12:58:00 +0900", "snippet": "🔗 옵저버 패턴 알아보기https://oyhun00.github.io/posts/design-pattern-behavioral-observer/상태가 변하는 특정 객체를 관찰자(옵저버)들이 관찰(구독)하고, 특정 객체에서 상태의 변화가 나타날 때 자신을 구독하고 있는 옵저버들에게 상태가 변화 됐음을 알려주는(발행) 발행/구독 패턴이다. 저번에 작성한 옵저버 패턴을 기반으로 리액트에 적용해보자.🛎️ 버튼 클릭 시, 여러 이벤트를 실행하는 인터랙션 만들기사용자가 버튼을 클릭할 때, 알림창과, 토스트 알림 그리고 행동을 기록하기 위해 로그를 남기는 인터랙션을 구현해보자. 다음은 Subject 클래스와 인터페이스이다.interface Subject { subscribe(obs: Observer): void; unsubscribe(obs: Observer): void; notify(data: String): void;}class Observable implements Subject { private observers: Observer[]; constructor() { this.observers = []; } subscribe(obs: Observer) { this.observers.push(obs); } unsubscribe(obs: Observer) { this.observers = this.observers.filter((observer) =&gt; observer !== obs); } notify(data: String) { this.observers.forEach((observer) =&gt; observer(data)); }}Subject 클래스에서의 기능은 다음과 같다. observers: Subject 객체의 상태 변화를 관찰(구독)할 옵저버들이 담겨져 있다. subscribe: Subject 객체의 상태 변화를 관찰(구독)할 옵저버들을 추가한다. unsubscribe: Subject 객체의 상태 변화를 구독하고 있는 특정 옵저버를 제거(구독 해제)한다. notify: Subject 객체의 상태 변화를 관찰(구독)하고 있는 옵저버들에게 변화를 알린다이제 Subject 객체를 구독할 Observer 를 리액트에서 구현해보자. 사용자가 버튼을 클릭하게 되면, Subject 클래스에서 구독하고 있는 옵저버들에게 변화를 알리는 notify 를 실행하여, 각 옵저버들에게 업데이트를 실행하도록 한다.const App = () =&gt; { const handleClick = () =&gt; { Observable.notify(\"Click !\"); }; const eventAlert: Observer = (data: String) =&gt; { alert(data); }; const eventLogger: Observer = (data: String) =&gt; { console.log(data); }; const eventToastify: Observer = (data: String) =&gt; { toast(data); }; Observable.subscribe(eventAlert); Observable.subscribe(eventLogger); Observable.subscribe(eventToastify); return ( &lt;&gt; &lt;button onClick={handleClick}&gt;Button&lt;/button&gt; &lt;/&gt; );};eventAlert, eventLogger, eventToastify 함수는 Subject 객체를 구독할 Observer 가 된다. 이 옵저버들을 subscribe 를 통해 구독하게끔 하고, 버튼을 클릭하면 실행되는 handleClick 함수를 통해 업데이트를 실행하게 된다." }, { "title": "Factory", "url": "/posts/design-pattern-creational-factory/", "categories": "Design Pattern, Creational Pattern", "tags": "Design Pattern", "date": "2022-08-28 12:58:00 +0900", "snippet": "✏️ Factory (팩토리) 란?인스턴스 생성을 처리하는 클래스를 팩토리(Factory)라 한다. 인스턴스의 생성을 서브 클래스에게 결정하도록 위임하는 방식이다. 팩토리를 사용하게 되면 객체 생성 작업을 팩토리로 캡슐화하여 변경이 필요할 시점에 여기저기 수정할 필요 없이, 팩토리 클래스 하나만 수정하여 유지보수가 용이하도록 도와준다.🍕 피자집의 피자 제작 시스템 구성하기피자집에서 피자를 주문 받고, 구워서 포장하는 피자 제작 시스템을 구성해보자.public void orderPizza(String type) { Pizza pizza; if (type.equals(\"Cheeze\")) { pizza = new CheesePizza(); } else if (type.equals(\"Veggie\")) { pizza = new VeggiePizza(); } pizza.prepare(); pizza.bake(); pizza.box();}간단하게 치즈 피자와 야채 피자를 제작하는 시스템을 구성했다. 하지만 피자의 종류는 두 가지만 존재하진 않을 것이다. 분명 피자의 종류가 추가되고, 야채 피자는 상대적으로 수요가 적어 메뉴에서 사라질 수도 있다. 이제 기존에 존재하던 야채 피자를 메뉴에서 빼고, 페페로니 피자와 치킨 피자를 추가해보자.public void orderPizza(String type) { Pizza pizza; if (type.equals(\"Cheeze\")) { pizza = new CheesePizza(); } /* else if(type.equals(\"Veggie\")) { pizza = new VeggiePizza(); }*/ else if (type.equels(\"Pepperoni\")) { pizza = new PepperoniPizza(); } else if (type.equels(\"Chicken\")) { pizza = new ChickenPizza(); } pizza.prepare(); pizza.bake(); pizza.box();}이제 앞으로 새로운 피자 메뉴가 출시되거나, 특정 피자를 메뉴에서 빼기 위해선 코드를 변경하고, 삭제해야할 것이다. 이렇게 되면 추후에 유지보수가 어려워지고, 유연성이 떨어질 것이다. 저렇게 변경에 열려있는 코드를 개방 폐쇄 원칙(OCP)에 따라 변경에 닫혀있도록 수정해야한다.💊 피자 객체를 생성하는 팩토리 만들기우선 변화가 자주 일어나는 곳을 찾아서 캡슐화를 하려한다. 위 코드에서 볼 수 있듯이 변경되는 부분은 인스턴스를 생성하는 구상 클래스를 선택하는 분기문이다.if (type.equals(\"Cheeze\")) { pizza = new CheesePizza();} /* else if (type.equals(\"Veggie\")) { pizza = new VeggiePizza();} */else if (type.equels(\"Pepperoni\")) { pizza = new PepperoniPizza();} else if (type.equels(\"Chicken\")) { pizza = new ChickenPizza();}피자 인스턴스만 생성할 수 있도록 위 코드를 따로 분리한다.public class SimplePizzaFactory { public Pizza createPizza(String type) { Pizza pizza = null; if (type.equals(\"Cheeze\")) { pizza = new CheesePizza(); } else if (type.equels(\"Pepperoni\")) { pizza = new PepperoniPizza(); } else if (type.equels(\"Chicken\")) { pizza = new ChickenPizza(); } return pizza; }}public class PizzaStore { SimplePizzaFactory simplePizzaFactory; public PizzaStore(SimplePizzaFactory simplePizzaFactory) { this.simplePizzaFactory = simplePizzaFactory; } public void orderPizza(String type) { Pizza pizza; pizza = simplePizzaFactory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.box(); }}이제 피자 인스턴스를 생성하는 과정을 캡슐화함으로써 PizzaStore 클래스는 피자 생성 과정 따위 몰라도 된다. 단지 피자를 준비하고, 굽고, 포장하는 과정만 수행하면 피자를 만들 수 있게 되었다.💩 변경되는 코드를 단지 분리했을 뿐인거 같은데?이렇게 캡슐화해서 분리해서 얻는 이득이 있나 의문점을 가졌었지만, SimplePizzaFactory 팩토리 클래스를 사용하는 여러 클라이언트에서 사용할 수 있는 상황에서 피자를 생성하는 작업을 팩토리 클래스 하나만 수정하여 리소스를 줄일 수 있다. 하지만 여전히 인스턴스를 생성하는 과정에서 여러가지 문제가 발생할 수 있는데, 이 부분은 다른 생성 패턴을 활용하여 인스턴스를 생성하는 코드를 삭제할 것이다.📚 Reference헤드퍼스트 디자인패턴 - [에릭 프리먼, 엘리자베스 롭슨, 케이시 시에라, 버트 베이츠]" }, { "title": "Decorator Pattern", "url": "/posts/design-pattern-structural-decorator/", "categories": "Design Pattern, Structural Pattern", "tags": "Design Pattern", "date": "2022-08-27 12:58:00 +0900", "snippet": "✏️ Decorator Pattern (데코레이터 패턴) 이란? 기본 기능에 추가할 수 있는 기능의 종류가 많은 경우, 각 추가 기능을 Decorator 클래스로 정의한 후 필요한 Decorator 객체를 조합함으로써 추가 기능의 조합을 설계하는 방식 - 위키백과객체에 추가적인 기능을 서브 클래스를 생성하는 방식보다 훨씬 유연하게 동적으로 객체를 결합하며 추가할 수 있는 패턴이다.🚘 도로를 표시하는 네비게이션 SW 만들기네비게이션의 기능은 다음과 같이 2가지의 기능이 있다. 도로를 간단한 선으로 표시 도로의 차선을 표시기본적으로 이 네비게이션은 도로를 간단한 선으로 표시하고, 차선은 사용자가 선택하여 기능을 보여줄 수 있다. 기본적으로 보여주는 도로와 추가로 차선을 표시하여 제공하고 싶다면 RoadDisplay 클래스와 이를 상속받는 RoadDisplayWithLane 클래스를 설계해야 할 것이다.public class RoadDisplay { public void draw() { System.out.println(\"Default Road Display\"); }}public class RoadWithLaneDisplay extends RoadDisplay { public void draw() { super.draw(); drawLane(); } private void drawLane() { System.out.println(\"\\tLane Display\"); }}public static void main(String[] args) { RoadDisplay roadDisplay = new RoadDisplay(); roadDisplay.draw(); RoadDisplay roadWithLaneDisplay = new RoadWithLaneDisplay(); roadWithLaneDisplay.draw();}RoadDisplay 클래스는 기본 도로 표시 기능만 제공하도록 하고, RoadDisplay 클래스를 상속받는 RoadWithLaneDisplay 클래스는 기본 도로 표시 기능에 추가적으로 차선 표시 기능을 더하기 위해 draw 메소드를 오버라이드하여 구현한다.Default Road DisplayDefault Road Display Lane Display💣 문제점만약 도로의 차선 표시 기능 뿐만 아니라, 교통량과 교차로를 표시하는 기능을 제공하고, 이 기능을 동시에 보여주는 즉, 조합하기 위해선 다음과 같이 수많은 하위 클래스를 설계하고 추가적인 메소드들을 작성해야 할 것이다.public class RoadWithLaneDisplay extends RoadDisplay() { ... }public class RoadWithTrafficDisplay extends RoadDisplay() { ... }public class RoadWithTrafficAndLaneDisplay extends RoadDisplay() { ... }...💡 해결법이렇게 조합별로 클래스가 늘어나는 문제를 해결하기 위해 우리는 데코레이터 패턴을 적용하여 해결할 수 있다. 기본 기능인 RoadDisplay 객체에 부가적인 기능(Decorator)인 Traffic , Lane 들을 장식(Decorate)하여 해결해보자.(UML)각 부가적인 기능(Decorator) 클래스에서는 기본 기능인 RoadDisplay 클래스가 draw 메소드를 호출하도록 하고, 데코레이터들이 가지고 있는 기능은 직접 제공하도록 한다.public abstract class Display { public abstract void draw();}기능을 표시하는 Display 추상 클래스를 작성하여 draw 메소드를 서브 클래스에서 작성하도록 한다.public class RoadDisplay extends Display { public void draw() { System.out.println(\"Road Display\"); }}기본 기능인 도로 표시 기능을 구현한다. draw 메소드는 Display 추상 클래스에서 상속 받아 기능을 구현한다.public abstract class DisplayDecorator extends Display { private Display decoratedDisplay; public DisplayDecorator(Display decoratedDisplay) { this.decoratedDisplay = decoratedDisplay; }; public void draw() { decoratedDisplay.draw(); };}Decorator의 공통 기능을 제공하는 DisplayDecorator 클래스를 작성한다.public class LaneDecorator extends DisplayDecorator { public LaneDecorator(Display decoratedDisplay) { super(decoratedDisplay); } public void draw() { super.draw(); drawLane(); } private void drawLane() { System.out.println(\"\\tLane Display\"); }}public class TrafficDecorator extends DisplayDecorator { public TrafficDecorator(Display decoratedDisplay) { super(decoratedDisplay); } public void draw() { super.draw(); drawLane(); } private void drawLane() { System.out.println(\"\\tTraffic Display\"); }}public class CameraDecorator extends DisplayDecorator { ... }LaneDecorator, TrafficDecorator, CameraDecorator 클래스는 실제로 기본 기능에 추가적으로 장식해줄 Decorator 이므로, DisplayDecorator 추상 클래스를 상속 받도록 한다. DisplayDecorator 에서 상속받은 draw() 메소드를 오버라이드하여, 각 부가 기능(Decorator)이 수행해야 할 기능만 추가로 작성한다.public class Main{ public static void main(String[] args) { Display roadDisplay = new RoadDisplay(); roadDisplay.draw(); Display roadWithLaneDisplay = new LaneDecorator(new RoadDisplay()); roadWithLaneDisplay.draw(); Display roadWithTrafficDisplay = new TrafficDecorator(new RoadDisplay()); roadWithTrafficDisplay.draw(); Display roadWithLaneAndTrafficDisplay = new RoadDisplay(); roadWithLaneAndTrafficDisplay = new TrafficDecorator(roadWithLaneAndTrafficDisplay); roadWithLaneAndTrafficDisplay = new LaneDecorator(roadWithLaneAndTrafficDisplay); roadWithLaneAndTrafficDisplay.draw(); }}각 인스턴스 객체는 모두 Display 클래스를 통해 생성되고 있다. Main 클래스는 동일한 Display 클래스를 통해 일관성 있는 방식으로 기능을 제공할 수 있다. 이렇게 데코레이터 패턴을 통해 기능이 추가 될 때마다, 수많은 하위 클래스를 생성하지 않고도, 각 데코레이터 별로 조합하여 설계할 수 있게 되었다." }, { "title": "Observer Pattern", "url": "/posts/design-pattern-behavioral-observer/", "categories": "Design Pattern, Behavioral Pattern", "tags": "Design Pattern", "date": "2022-08-21 12:58:00 +0900", "snippet": "✏️ Observer Pattern (옵저버 패턴) 이란? 옵서버 패턴은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴이다. 주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용된다. - 위키백과상태가 변하는 특정 객체를 관찰자(옵저버)들이 관찰(구독)하고, 특정 객체에서 상태의 변화가 나타날 때 자신을 구독하고 있는 옵저버들에게 상태가 변화 됐음을 알려주는(발행) 발행/구독 패턴이다. 객체의 상태 변화를 감지하기 위해 사용될 수 있는 polling 방식을 지양하거나, 상대 클래스나 객체에 의존하지 않고 상태 변화를 통보하기 위해 유용한 패턴이다. 대표적으로 자바스크립트에서 onClick과 같은 이벤트 핸들러들을 예로 들을 수 있다.🙋‍♂️ 특정 유저의 정보 조회하기어느 웹 어플리케이션에서 유저 목록을 확인할 수 있는 테이블이 있다. 이 테이블에서 특정 유저를 클릭하면 해당하는 유저 ID의 변화를 감지하여 자동으로 정보를 가져오는 기능을 구현한다.UserTable 클래스에서 특정 유저를 선택하는 selectUserId 메서드가 실행되면 userId 값을 저장하고, userInfoView.update() 메서드를 통해 값이 변경됨을 통보함으로써 변화를 감지하도록 한다.public class UserTable { private String userId; private UserInfoView userInfoView; public void setUserInfoView(UserInfoView userInfoView) { this.userInfoView = userInfoView; } public String getUserId() { return userId; } public void selectUserId(String userId) { this.userId = userId; userInfoView.update(); }}public class UserInfoView { private UserTable userTable; public UserInfoView(UserTable userTable) { this.userTable = userTable; } public void display(String userId) { System.out.println(\"================ \" + userId + \" User Info ===============\"); System.out.println(\"User ID: ...\"); System.out.println(\"User Name: ...\"); System.out.println(\"===============================================\"); System.out.println(\"\"); } public void update() { String userId = userTable.getUserId(); display(userId); }}public static void main(String[] args) { UserTable userTable = new UserTable(); UserInfoView userInfoView = new UserInfoView(userTable); userTable.setUserInfoView(userInfoView); userTable.selectUserId(\"U001\");}================ U001 User Info ===============User ID: ...User Name: ...===============================================의도했던 대로 유저를 선택하면 변화된 userId 값을 감지하고 해당 유저의 기본 정보를 출력하게 되었다.💣 문제점하지만 만약 우리가 유저 목록 테이블에서 선택한 유저 ID가 변화할 때, 해당 유저의 기본 정보뿐만 아니라, 결제 기록, 활동 로그 등 다양한 데이터를 가져오게 하고 싶다면 UserTable 클래스를 직접 수정해야 할 것이다.public class UserTable { private String userId; private UserInfoView userInfoView; private UserLogView userLogView; public void setUserInfoView(UserInfoView userInfoView) { this.userInfoView = userInfoView; } public void setUserLogView(UserLogView userLogView) { this.userLogView = userLogView; } public String getUserId() { return userId; } public void selectUserId(String userId) { this.userId = userId; userInfoView.update(); userLogView.update(); }}public class UserLogView { private UserTable userTable; public UserLogView(UserTable userTable) { this.userTable = userTable; } public void display(String userId) { System.out.println(\"================ \" + userId + \" User Log ===============\"); System.out.println(\"2022-08-21 12:45:50: ...\"); System.out.println(\"2022-08-19 09:21:00: ...\"); System.out.println(\"2022-08-17 06:01:21: ...\"); System.out.println(\"2022-08-16 14:58:44: ...\"); System.out.println(\"2022-08-15 16:22:07: ...\"); System.out.println(\"2022-08-14 20:11:54: ...\"); System.out.println(\"===============================================\"); System.out.println(\"\"); } public void update() { String userId = userTable.getUserId(); display(userId); }}public static void main(String[] args) { UserTable userTable = new UserTable(); UserInfoView userInfoView = new UserInfoView(userTable); UserLogView userLogView = new UserLogView(userTable); userTable.setUserInfoView(userInfoView); userTable.setUserLogView(userLogView); userTable.selectUserId(\"U001\");}================ U001 User Info ===============User ID: ...User Name: ...=============================================================== U001 User Log ===============2022-08-21 12:45:50: ...2022-08-19 09:21:00: ...2022-08-17 06:01:21: ...2022-08-16 14:58:44: ...2022-08-15 16:22:07: ...2022-08-14 20:11:54: ...===============================================새로운 유저 정보 View를 추가하여 적용하기 위해 UserTable 클래스를 직접적으로 수정하게 됐다. 이렇게 작성하게 된다면 해당 유저의 다른 정보 조회의 기능이 추가 될 때마다 UserTable 클래스를 반복적으로 수정해야할 것이다. 이는 곧 개방 폐쇄 원칙(Open Close Principle)에 위배하게 된다.💡 해결법이렇게 정보 조회의 기능이 추가되거나 수정이 되어도, UserTable 클래스를 변경하지 않고 그대로 재사용 할 수 있어야 한다. 옵저버 패턴을 적용하여 이 문제를 해결해보자.앞서 말했듯 옵저버 패턴은 상태가 변하는 특정 객체를 옵저버들이 구독하고, 특정 객체에서 상태의 변화가 나타날 때 자신을 구독하고 있는 옵저버들에게 상태가 변화 됐음을 통지하는 패턴이라 설명했다. Subject 클래스를 통해 변화하는 객체를 감시하는 옵저버들을 구독시키거나, 해제한다. 그리고 옵저버가 될 객체는 observer 인터페이스를 구현하도록 하고, 선택한 유저 ID가 변화할 때 즉, UserTable 클래스의 selectUserId 메소드가 실행되면, Subject 클래스의 notifyObserver 메소드를 실행하여, 구독하고 있는 옵저버들에게 변화를 통지한다. 통지받은 옵저버들은 Observer 인터페이스를 통해 update 메소드를 실행하게 된다.public interface Observer { public void update();}통지 대상을 인터페이스로 추상화하고, 변화를 통지 받았을 때 처리하는 update 메서드를 추가한다.public abstract class Subject { private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); public void subscribe(Observer observer) { observers.add(observer); }; public void unsubscribe(Observer observer) { observers.remove(observer); }; public void notifyObservers() { for (Observer o:observers) { o.update(); } };}통지 대상인 옵저버를 구독하고, 해제하는 기능을 구현한다.public class UserTable extends Subject { private String userId; public String getUserId() { return userId; } public void selectUserId(String userId) { this.userId = userId; notifyObservers(); }}userId가 변화하면 각 옵저버들에게 변화를 알린다.public class UserInfoView implements Observer { private UserTable userTable; public UserInfoView(UserTable userTable) { this.userTable = userTable; } public void display(String userId) { System.out.println(\"================ \" + userId + \" User Info ===============\"); System.out.println(\"User ID: ...\"); System.out.println(\"User Name: ...\"); System.out.println(\"===============================================\"); System.out.println(\"\"); } public void update() { String userId = userTable.getUserId(); display(userId); }}public class UserLogView implements Observer { private UserTable userTable; public UserLogView(UserTable userTable) { this.userTable = userTable; } public void display(String userId) { System.out.println(\"================ \" + userId + \" User Log ===============\"); System.out.println(\"2022-08-21 12:45:50: ...\"); System.out.println(\"2022-08-19 09:21:00: ...\"); System.out.println(\"2022-08-17 06:01:21: ...\"); System.out.println(\"2022-08-16 14:58:44: ...\"); System.out.println(\"2022-08-15 16:22:07: ...\"); System.out.println(\"2022-08-14 20:11:54: ...\"); System.out.println(\"===============================================\"); System.out.println(\"\"); } public void update() { String userId = userTable.getUserId(); display(userId); }}public static void main(String[] args) { UserTable userTable = new UserTable(); UserInfoView userInfoView = new UserInfoView(userTable); UserLogView userLogView = new UserLogView(userTable); userTable.subscribe(userInfoView); userTable.subscribe(userLogView); userTable.selectUserId(\"U001\"); userTable.unsubscribe(userLogView); userTable.selectUserId(\"U002\");}상속받은 Observer 인터페이스의 update 메소드를 구현함으로써 옵저버가 된다.================ U001 User Info ===============User ID: ...User Name: ...=============================================================== U001 User Log ===============2022-08-21 12:45:50: ...2022-08-19 09:21:00: ...2022-08-17 06:01:21: ...2022-08-16 14:58:44: ...2022-08-15 16:22:07: ...2022-08-14 20:11:54: ...=============================================================== U002 User Info ===============User ID: ...User Name: ...===============================================이제 UserTable 클래스는 Subject 클래스를 상속받아 변화하는 객체를 구독하고 해지할 수 있도록 Subject 클래스를 통해 관리함으로써, 관심 객체를 직접 참조할 필요가 없게되었고, UserTable 클래스를 직접 수정하지 않고도 옵저버를 추가, 제거가 가능해져 객체가 느슨한 결합이 되었다고 볼 수 있을 것이다." }, { "title": "Command Pattern", "url": "/posts/design-pattern-behavioral-command/", "categories": "Design Pattern, Behavioral Pattern", "tags": "Design Pattern", "date": "2022-08-10 12:58:00 +0900", "snippet": "✏️ Command Pattern (커맨드 패턴) 이란? 커맨드 패턴(Command pattern)이란 요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 메서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴이다. - 위키백과즉, 이벤트가 발생할 때, 실행될 기능들을 캡슐화하고, 클래스를 변경하지 않도록 재사용성이 높은 클래스를 설계하는 패턴이다.🎮 만능 버튼 구현하기버튼이 눌리면, 특정 기능을 실행하는 프로그램을 구현한다. 우선 버튼을 누를 때, 램프의 불이 켜지는 프로그램을 구현해보자.public class Button { private Lamp lamp; public Button(Lamp lamp) { this.lamp = lamp; }; public void pressed() { lamp.turnOn(); };}public class Lamp { public void turnOn() { System.out.println(\"Lamp Turn On\"); };}public static void main(String[] args) { Lamp lamp = new Lamp(); Button button = new Button(lamp); button.pressed();}Button 생성자를 이용해 Lamp 객체를 전달하고, Button의 pressed 메서드가 실행되면 전달받은 Lamp 객체의 turnOn 메서드를 실행하여 기능을 수행하게 된다.💣 문제점버튼을 눌렀을 때, 램프의 불이 켜지는 기능 뿐만 아니라, 다른 기능을 추가하고 또 추가된 기능을 실행하고 싶다면?예를 들어 램프 대신 알람 기능을 실행하고 싶다면, Button 클래스를 수정해야 한다.public class Alarm { public void start() { System.out.println(\"Alarm Start\"); }}public class Button { private Alarm alarm; public Button(Alarm alarm) { this.alarm = alarm; }; public void pressed() { alarm.start(); };}public static void main(String[] args) { Alarm alarm = new Alarm(); Button button = new Button(alarm); button.pressed();}정상적으로 버튼을 눌렀을 때, 알람의 기능은 수행될 것이다. 그러나 기능을 변경하기 위해 기존의 Button 클래스를 수정하는 것은 SOLID 원칙에서 개방 폐쇄 원칙(Open Close Principle)에 위배하게 된다. 따라서 버튼을 눌렀을 때, 실행될 기능을 분기 처리하기 위해 기능을 선택할 수 있게끔 설계해야 한다.enum Mode { LAMP, ALARM }public class Button { private Lamp theLamp; private Alarm alarm; private Mode mode; public Button(Lamp theLamp, Alarm alarm) { this.theLamp = theLamp; this.alarm = alarm; }; public void setMode(Mode mode) { this.mode = mode; } public void pressed() { if (mode.equals(Mode.LAMP)) { theLamp.turnOn(); } else { alarm.start(); } } }public static void main(String[] args) { Lamp theLamp = new Lamp(); Alarm alarm = new Alarm(); Button button = new Button(theLamp, alarm); button.setMode(Mode.ALARM); button.pressed(); button.setMode(Mode.LAMP); button.pressed();}이제 버튼을 눌렀을 때, 분기 처리하여 특정 기능을 수행할 수 있도록 구현되었다. 하지만 알람 기능뿐만 아니라 보일러를 키는 기능, 에어컨을 키는 기능 등 여러가지 기능들이 추가된다면, 또 다시 Button 클래스를 수정해야할 것이고, 분기 처리하는 코드는 길어질 것이다. 이렇게 되면 재사용성 높은 설계라고 볼 순 없을 것이다.💡 해결법앞서 이야기한 코드의 문제점을 해결하기 위해, 커맨드 패턴을 적용함으로써 해결할 수 있다.Button 클래스를 수정하지 않고 사용하기 위해, pressed 메서드에서 기능을 직접 구현하는 대신, 버튼을 눌렀을 때, 실행되는 기능들을 캡슐화하여 외부에서 제공받도록 설계한다.아래는 커맨트 패턴을 적용한 클래스 다이어그램이다.이제 Button 클래스는 특정 기능을 실행할 때, Lamp나 Alarm의 메서드들을 직접 호출하지 않고, 정의된 Command 인터페이스를 통해 excute로 메서드를 호출한다. 그리고 Command 인터페이스를 상속받은 클래스들은 각각의 기능을 excute 메서드를 통해 기능을 구현한다.public interface Command { public abstract void execute();}각 기능들의 메서드들을 직접 호출하지 않도록 Command 인터페이스를 작성한다.public class Button { private Command theCommand; public Button(Command theCommand) { this.theCommand = theCommand; } public void setCommand(Command newCommand) { this.theCommand = newCommand; } public void pressed() { theCommand.execute(); }}pressed 메서드를 호출하면, 주어진 Command의 excute 메서드를 호출하도록 한다.public class LampOnCommand implements Command { private Lamp lamp; public LampOnCommand(Lamp lamp) { this.lamp = lamp; }; public void execute() { lamp.turnOn(); }}public class AlarmStartCommand implements Command { private Alarm alarm; public AlarmStartCommand(Alarm alarm) { this.alarm = alarm; } public void execute() { alarm.start(); }}앞서 설계한 인터페이스를 캡슐화한 각 기능들이 상속받아 인터페이스를 구현하고, Button 객체에 설정한다.public static void main(String[] args) { Lamp theLamp = new Lamp(); Command lampOnCommand = new LampOnCommand(theLamp); Button button1 = new Button(lampOnCommand); button1.pressed(); Alarm alarm = new Alarm(); Command alarmOnCommand = new AlarmStartCommand(alarm); Button button2 = new Button(alarmOnCommand); button2.pressed(); button2.setCommand(lampOnCommand); button2.pressed(); }버튼을 눌렀을 때, 실행될 기능은 Command 인터페이스를 구현한 클래스의 객체를 Button 객체에 설정하여 사용할 수 있게 되었다. 이제 OCP를 위배하지 않고 다양한 기능을 구현할 수 있다." }, { "title": "Strategy Pattern", "url": "/posts/design-pattern-behavioral-strategy/", "categories": "Design Pattern, Behavioral Pattern", "tags": "Design Pattern", "date": "2022-07-08 12:58:00 +0900", "snippet": "✏️ Strategy Pattern (전략패턴) 이란? 전략 패턴은 실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다. 특정한 계열의 알고리즘들을 정의하고, 각 알고리즘을 캡슐화하며, 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다. - 위키백과즉, 각각의 알고리즘(전략)들을 공통의 인터페이스를 구현하는 클래스로 캡슐화하고, 동적으로 전략을 쉽게 바꿀 수 있도록 설계하는 패턴이다.🕹️ 게임 캐릭터 구현하기RPG 게임을 개발하며, 전사, 마법사 이렇게 2가지 직업들을 구현해야하는 상황이다. 각각의 직업은 스킬도 모두 다를 것이다. 전사는 검을 휘두르고 걸어다니며 이동하고, 마법사는 파이어 볼을 발사하고 순간이동으로 이동한다. 현재까지의 상황을 코드로 작성해보자. public abstract class Adventurer { private String job; public Adventurer(String job) { this.job = job; } public String getJob() { return job; } public abstract void skill(); public abstract void move();}public class Warrior extends Adventurer { public Warrior(String job) { super(job); } public void skill() { System.out.println(\"검 휘두르기.\"); } public void move() { System.out.println(\"열심히 걷기.\"); }}public class Magician extends Adventurer { public Magician(String job) { super(job); } public void skill() { System.out.println(\"파이어볼 발사하기.\"); } public void move() { System.out.println(\"텔레포트로 이동하기.\"); }}public class Main { public static void main(String[] args) { Adventurer warrior = new Warrior(\"전사\"); Adventurer magician = new Magician(\"마법사\"); System.out.println(\"나는 \" + warrior.getJob()); warrior.attack(); warrior.move(); System.out.println(\"나는 \" + magician.getJob()); magician.attack(); magician.move(); }}나는 전사검 휘두르기.열심히 걷기.나는 마법사파이어볼 발사하기.텔레포트로 이동하기.이렇게 전사와 마법사 캐릭터가 구현되었다. 하지만 만약 전사의 공격 방식이 마법사의 파이어볼로 변경되고, 마법사의 공격 방식이 전사의 검 휘두르기로 변경해달라는 요청이 온다면? 또, 마검사라는 직업이 추가되어 공격 방식은 기존 전사의 검 휘두르기와 이동 방식은 마법사의 텔레포트로 구현해야 된다면 다음과 같이 구현하게 될 것이다.public class Warrior extends Adventurer { public Warrior(String job) { super(job); } public void skill() { System.out.println(\"파이어볼 발사하기.\"); } public void move() { System.out.println(\"열심히 걷기.\"); }}public class Magician extends Adventurer { public Magician(String job) { super(job); } public void skill() { System.out.println(\"검 휘두르기.\"); } public void move() { System.out.println(\"텔레포트로 이동하기.\"); }}public class MagicWarrior extends Adventurer { public MagicWarrior(String job) { super(job); } public void skill() { System.out.println(\"검 휘두르기.\"); } public void move() { System.out.println(\"텔레포트로 이동하기.\"); }}💣 코드의 문제점각 직업의 공격, 이동 스킬을 수정, 변경하기 위해 각각 클래스의 코드를 수정해야하는데, 이때 SOLID 원칙에서 개방 폐쇄 원칙(Open Close Principle)에 위배하게 된다. 또한 중복되는 코드가 나타나고, 마검사라는 직업이 추가되면서 마검사의 skill() 메소드와 move() 메소드의 내용이 중복된다.💡 해결법앞서 이야기한 코드의 문제점을 해결하기 위해, 전략 패턴을 적용함으로써 해결할 수 있다.위에서 전략패턴을 “각각의 알고리즘(전략)들을 공통의 인터페이스를 구현하는 클래스로 캡슐화하고, 동적으로 전략을 쉽게 바꿀 수 있도록 설계하는 패턴” 이라고 설명하였다. 이제 각 직업의 공격과 이동 방식(전략)을 공통의 인터페이스로 정의해보자.public interface AttackStrategy { public void attack(); }public interface MovingStrategy { public void move(); }이제 공격과 이동 스킬(전략)을 클래스로 구현한다.public class SmashStrategy implements AttackStrategy { public void attack() { System.out.println(\"검 휘두르기.\"); }}public class FireBallStrategy implements AttackStrategy { public void attack() { System.out.println(\"파이어볼 발사하기.\"); }}public class WalkingStrategy implements MovingStrategy { public void move() { System.out.println(\"열심히 걷기.\"); }}public class TeleportStrategy implements AttackStrategy { public void attack() { System.out.println(\"텔레포트로 이동하기.\"); }}각 직업의 공격과 이동 스킬(전략)은 인터페이스와 그 구현체로 분리했으니, 직업 클래스에서 공격과 이동 메소드는 제거한다.public class Magician extends Adventurer { public Magician(String job) { super(job); }}public class Warrior extends Adventurer { public Magician(String job) { super(job); }}public class MagicWarrior extends Adventurer { public MagicWarrior(String job) { super(job); }}그리고 Adventurer 클래스는 다음과 같이 수정한다.public abstract class Adventurer { private String job; private AttackStrategy attackStrategy; private MovingStrategy movingStrategy; public Adventurer(String job) { this.job = job; } public String getJob() { return job; } public void attack() { attackStrategy.attack(); } public void move() { movingStrategy.move(); } public void setAttackStrategy(AttackStrategy attackStrategy) { this.attackStrategy = attackStrategy; } public void setMovingStrategy(MovingStrategy movingStrategy) { this.movingStrategy = movingStrategy; } }setAttackStrategy, setMovingStrategy 을 통해 공격과 이동 전략을 주입 받고 AttackStrategy, MovingStrategy 인터페이스에서 공격과 이동 전략을 가져올 수 있다.public class Main { public static void main(String[] args) { Adventurer warrior = new Warrior(\"전사\"); Adventurer magician = new Magician(\"마법사\"); Adventurer magicWarrior = new MagicWarrior(\"마검사\"); warrior.setAttackStrategy(new FireBallStrategy()); warrior.setMovingStrategy(new WalkingStrategy()); magician.setAttackStrategy(new SmashStrategy()); magician.setMovingStrategy(new TeleportStrategy()); magicWarrior.setAttackStrategy(new SmashStrategy()); magicWarrior.setMovingStrategy(new TeleportStrategy()); System.out.println(\"나는 \" + warrior.getJob()); warrior.attack(); warrior.move(); System.out.println(\"나는 \" + magician.getJob()); magician.attack(); magician.move(); System.out.println(\"나는 \" + magicWarrior.getJob()); magicWarrior.attack(); magicWarrior.move(); }}이제 setAttackStrategy 와 setMovingStrategy의 전략을 통해 각 직업군 마다 스킬을 개방 폐쇄 원칙을 어기지 않고 변경할 수 있고, 중복되는 코드 없이 스킬을 추가하거나 변경할 수 있게 되었다." }, { "title": "React Hook Form", "url": "/posts/javascript-react-react-hook-form/", "categories": "JavaScript, React", "tags": "React, React Hook Form", "date": "2022-07-06 12:58:00 +0900", "snippet": "✏️ React Hook FormReact는 State가 변화하면 리렌더링하는 특징이 있다. 이러한 많은 State가 변화할 때마다, 렌더링을 여러번 수행하게 되고, 이는 곧 성능 저하로 이어진다. React Hook Form은 필드들을 State를 통해 관리하지 않고 Ref를 통해 관리하기 때문에 기본적으로 렌더링이 발생하지 않는다. 또한 Validation과 Submit 등 간편하게 구현할 수 있고, 의존성이 없는 라이브러리다" }, { "title": "JavaScript Scope", "url": "/posts/javascript-scope/", "categories": "JavaScript, Core", "tags": "JavaScript", "date": "2022-06-28 12:33:00 +0900", "snippet": "✏️ 스코프란?우선 스코프(Scope)란 단어의 뜻은 범위라는 의미를 가지고 있다. 자바스크립트에서 스코프(Scope)도 변수 참조의 유효 범위를 나타낸다. 스코프는 전역 스코프(Global scope)와 지역 스코프(Local scope) 두 가지로 구분할 수 있다. 전역: 전역 범위에서 정의 되었으며, 어디서든지 참조할 수 있는 것 지역: 함수 내에서 정의되어 함수 내에서만 참조할 수 있는 것 코드를 보면서 이해해보도록 하자. 아래 코드의 로그 출력 값은 어떻게 나올까?// 예제 1var foo = 'global';function func1() { var foo = 'local'; console.log(foo); // ?}func1();console.log(foo); // ? 변수 foo가 전역, 그리고 func1() 함수 내부에서 선언되어있는 상태다. func1() 함수 내부에 위치한 콘솔 로그는 func1() 함수 내부에서 선언된 변수 foo를 참조하게 된다. 반면에 전역에 위치한 콘솔로그는 전역에서 선언된 foo 변수를 참조한다.이처럼 지역(함수) 내에서 선언된 변수는 지역(함수) 내에서만 참조할 수 있고, 함수 외부에서는 참조할 수 없다. 반대로 전역에서 선언된 변수는 어디에서나 참조할 수 있다. 이를 스코프(Scope)라고 하고 이는 곧 함수 레벨 스코프라고 한다.자바스크립트의 스코프는 블록 레벨 스코프가 아닌 논 블록 레벨 스코프 다.// 예제 2if (condition) { var foo = true;}console.log(foo); // true위 코드에서 중괄호 부분 { ... } 이 블록이다. 만약 저 if문이 전역에 선언되었다면, 블록 내에서 선언되었더라도 변수 foo는 전역 변수가 된다.다만 ES6부터는 블록 레벨 스코프를 사용할 수 있는데, 간단하게만 예제 코드를 보고, 이 부분은 추후에 자세히 다루도록 하겠다.if (condition) { let foo = true;}console.log(a); // a is not defined차이점은 변수 선언 시, 키워드를 var가 아닌 let으로 선언했다. ES6 부터 let, const 라는 새로운 선언 방법이 있다.🔗 스코프 체인 (Scope Chain)지역 스코프는 함수 내에서만 정의된 것들을 참조할 수 있는 유효 범위라고 했는데, 그렇다면 함수 내부에 함수가 있다면 어떻게 될까? 아래 코드의 출력 값을 예상해보자.// 예제 3var foo = '전역';function func1() { var foo = '지역'; function func2() { console.log(foo); // ? } func2(); console.log(foo); // ?}func1(); func2() 함수 내부의 콘솔 로그는 func1() 함수 내부에 선언된 foo변수를 참조하게 된다. func2() 내부에 선언된 foo 변수가 없는데 어떻게 상위 함수인 func1() 에서 선언된 변수를 참조하는 걸까?자바스크립트는 변수를 참조할 때, 자신의 지역(스코프)에 선언된 변수를 찾게 된다. 만약 해당 지역에 변수를 못 찾게 된다면 상위 지역으로 올라가 변수를 찾는 성질이 있다. 이를 스코프 체인이라고 한다.만약 전역 지역에도 참조 값이 없다면 Uncaught ReferenceError: foo is not defined 에러를 출력하게 된다.📍 렉시컬 스코프 (Lexical Scope)바로 위의 예제 2 코드를 아래 코드로 조금 변형해보았다. 아래 코드는 출력 값이 어떻게 될까?// 예제 4var foo = '전역';function func2() { console.log(foo); // ?}function func1() { var foo = '지역'; func2(); console.log(foo); // ?}func1();func2();이번 코드는 func2() 함수가 전역에서 선언되었고, func1() 함수 내부에서 호출이 되었다. 어차피 func2() 함수의 콘솔로그는 func1() 내부에서 호출 되었으니, func1() 의 변수 foo를 참조하지 않을까? 라는 생각이 들겠지만 그렇지 않다.자바스크립트는 스코프를 정할 때, 함수가 어디서 호출되었는지가 아닌, 어디서 선언되었느냐에 따라 결정된다.예제 3 코드를 보시면 func2() 함수는 호출은 func1() 내부에서 호출되었지만, 전역 스코프에 선언되었다. 위에서 자바스크립트는 자신의 스코프에서 선언된 변수를 먼저 참조한다고 했다. 따라서 마찬가지로 전역에 선언된 func2() 함수는 전역에 선언된 변수를 참조하게 된다. 이를 렉시컬 스코프(정적 스코프)라고 한다." } ]
